/**
 * malware.ts — ClamAV TCP integration for document scanning.
 *
 * Connects to ClamAV daemon via TCP (INSTREAM command),
 * streams the file buffer, and returns scan result.
 *
 * Architecture §6 Layer 1: Pre-Upload Validation.
 */

import net from "net";

const CLAMAV_HOST = process.env.CLAMAV_HOST || "localhost";
const CLAMAV_PORT = parseInt(process.env.CLAMAV_PORT || "3310", 10);
const CONNECT_TIMEOUT_MS = 5000;
const SCAN_TIMEOUT_MS = 30000;

export interface ScanResult {
    clean: boolean;
    threat?: string;
}

/**
 * Scan a file buffer for malware using ClamAV INSTREAM protocol.
 *
 * Protocol:
 *  1. Send "zINSTREAM\0"
 *  2. Send chunks: 4-byte big-endian length + chunk data
 *  3. Send terminator: 4 zero bytes
 *  4. Read response: "stream: OK" or "stream: <virus> FOUND"
 */
export async function scanBuffer(buffer: Buffer): Promise<ScanResult> {
    return new Promise((resolve, reject) => {
        const socket = new net.Socket();
        let response = "";

        socket.setTimeout(CONNECT_TIMEOUT_MS);

        socket.on("connect", () => {
            socket.setTimeout(SCAN_TIMEOUT_MS);

            // Send INSTREAM command
            socket.write("zINSTREAM\0");

            // Send buffer in chunks (max 2KB each per ClamAV protocol)
            const CHUNK_SIZE = 2048;
            for (let i = 0; i < buffer.length; i += CHUNK_SIZE) {
                const chunk = buffer.subarray(i, i + CHUNK_SIZE);
                const sizeHeader = Buffer.alloc(4);
                sizeHeader.writeUInt32BE(chunk.length, 0);
                socket.write(sizeHeader);
                socket.write(chunk);
            }

            // Send terminator (4 zero bytes)
            const terminator = Buffer.alloc(4);
            terminator.writeUInt32BE(0, 0);
            socket.write(terminator);
        });

        socket.on("data", (data) => {
            response += data.toString();
        });

        socket.on("end", () => {
            const trimmed = response.trim();

            if (trimmed.endsWith("OK")) {
                resolve({ clean: true });
            } else if (
                trimmed.includes("INSTREAM size limit exceeded") ||
                trimmed.startsWith("ERROR")
            ) {
                // ClamAV protocol errors — not a threat, but scan failed
                reject(
                    new Error(
                        `ClamAV scan error: ${trimmed}`
                    )
                );
            } else {
                // Extract virus name: "stream: Win.Test.EICAR FOUND"
                const match = trimmed.match(/stream:\s+(.+)\s+FOUND/);
                resolve({
                    clean: false,
                    threat: match?.[1] || "Unknown threat",
                });
            }
        });

        socket.on("timeout", () => {
            socket.destroy();
            reject(new Error("ClamAV connection timeout"));
        });

        socket.on("error", (err) => {
            socket.destroy();
            reject(new Error(`ClamAV scan failed: ${err.message}`));
        });

        socket.connect(CLAMAV_PORT, CLAMAV_HOST);
    });
}
